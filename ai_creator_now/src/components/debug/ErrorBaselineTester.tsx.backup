import React, { useState, useEffect } from 'react';
import { Activity, Target, TrendingUp, AlertTriangle, CheckCircle, Clock, BarChart3, Play, RefreshCw, Download } from 'lucide-react';
import { errorMonitor } from '../../utils/errorMonitor';
import { useErrorMonitor } from '../../ui/ErrorBoundary';

interface BaselineMetrics {
  timestamp: string;
  totalErrors: number;
  errorsByType: Record<string, number>;
  userActions: number;
  sessionDuration: number;
  memoryUsage?: number;
  performanceMetrics?: {
    domContentLoaded: number;
    loadComplete: number;
    firstInput: number;
  };
}

interface BenchmarkTest {
  id: string;
  name: string;
  description: string;
  test: () => Promise<{ success: boolean; duration: number; errors: number }>;
  expectedResults: {
    maxErrors: number;
    maxDuration: number;
    successRate: number;
  };
}

export const ErrorBaselineTester: React.FC = () => {
  const [isRunning, setIsRunning] = useState(false);
  const [currentTest, setCurrentTest] = useState<string | null>(null);
  const [baseline, setBaseline] = useState<BaselineMetrics | null>(null);
  const [testResults, setTestResults] = useState<any[]>([]);
  const [comparison, setComparison] = useState<any>(null);
  const { getErrors, clearErrors } = useErrorMonitor();

  // 基准测试套件
  const benchmarkTests: BenchmarkTest[] = [
    {
      id: 'rapid-clicking',
      name: '快速点击测试',
      description: '模拟用户快速点击按钮，测试竞态条件处理',
      test: async () => {
        const startTime = Date.now();
        let errors = 0;
        const initialErrorCount = errorMonitor.getErrors().length;

        try {
          // 模拟快速连续操作
          for (let i = 0; i < 10; i++) {
            await new Promise(resolve => setTimeout(resolve, 50));
            // 触发一些用户操作
            errorMonitor.logUserAction('click', `test-button-${i}`, {});
          }
        } catch (error) {
          errors++;
        }

        const finalErrorCount = errorMonitor.getErrors().length;
        const duration = Date.now() - startTime;

        return {
          success: errors === 0,
          duration,
          errors: finalErrorCount - initialErrorCount
        };
      },
      expectedResults: {
        maxErrors: 0,
        maxDuration: 1000,
        successRate: 100
      }
    },
    {
      id: 'async-error-handling',
      name: '异步错误处理测试',
      description: '测试异步操作中的错误捕获和处理',
      test: async () => {
        const startTime = Date.now();
        let errors = 0;
        const initialErrorCount = errorMonitor.getErrors().length;

        try {
          // 模拟异步操作错误
          await Promise.all([
            new Promise((_, reject) =>
              setTimeout(() => reject(new Error('Async test error 1')), 100)
            ),
            new Promise((_, reject) =>
              setTimeout(() => reject(new Error('Async test error 2')), 150)
            ),
            new Promise(resolve =>
              setTimeout(() => resolve('success'), 200)
            )
          ]);
        } catch (error) {
          // 应该被错误监控系统捕获
          errors++;
        }

        const finalErrorCount = errorMonitor.getErrors().length;
        const duration = Date.now() - startTime;

        return {
          success: true, // 即使有错误也是预期的
          duration,
          errors: finalErrorCount - initialErrorCount
        };
      },
      expectedResults: {
        maxErrors: 5,
        maxDuration: 500,
        successRate: 100
      }
    },
    {
      id: 'memory-alloc',
      name: '内存分配测试',
      description: '测试大量数据操作时的内存管理',
      test: async () => {
        const startTime = Date.now();
        let errors = 0;
        const initialErrorCount = errorMonitor.getErrors().length;

        try {
          // 创建大量对象测试内存处理
          const largeArray = Array.from({ length: 10000 }, (_, i) => ({
            id: i,
            data: new Array(1000).fill(`test-data-${i}`),
            nested: {
              level1: { level2: { level3: new Array(100).fill(i) } }
            }
          }));

          // 模拟数据处理
          largeArray.forEach(item => {
            JSON.stringify(item);
            Object.freeze(item);
          });

          // 清理引用
          largeArray.length = 0;
        } catch (error) {
          errors++;
        }

        const finalErrorCount = errorMonitor.getErrors().length;
        const duration = Date.now() - startTime;

        return {
          success: errors === 0,
          duration,
          errors: finalErrorCount - initialErrorCount
        };
      },
      expectedResults: {
        maxErrors: 0,
        maxDuration: 2000,
        successRate: 100
      }
    },
    {
      id: 'component-lifecycle',
      name: '组件生命周期测试',
      description: '测试组件挂载、更新、卸载时的错误处理',
      test: async () => {
        const startTime = Date.now();
        let errors = 0;
        const initialErrorCount = errorMonitor.getErrors().length;

        try {
          // 模拟组件生命周期事件
          for (let i = 0; i < 5; i++) {
            errorMonitor.logUserAction('mount', `test-component-${i}`, {});
            await new Promise(resolve => setTimeout(resolve, 100));
            errorMonitor.logUserAction('update', `test-component-${i}`, {});
            await new Promise(resolve => setTimeout(resolve, 50));
            errorMonitor.logUserAction('unmount', `test-component-${i}`, {});
          }
        } catch (error) {
          errors++;
        }

        const finalErrorCount = errorMonitor.getErrors().length;
        const duration = Date.now() - startTime;

        return {
          success: errors === 0,
          duration,
          errors: finalErrorCount - initialErrorCount
        };
      },
      expectedResults: {
        maxErrors: 0,
        maxDuration: 1500,
        successRate: 100
      }
    }
  ];

  // 收集当前系统指标作为基准线
  const collectBaselineMetrics = (): BaselineMetrics => {
    const errors = errorMonitor.getErrors();
    const userActions = errorMonitor.getUserActions();
    const sessionStart = sessionStorage.getItem('sessionStart');
    const sessionDuration = sessionStart ?
      Date.now() - parseInt(sessionStart) : 0;

    // 获取性能指标
    const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
    const performanceMetrics = {
      domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,
      loadComplete: navigation.loadEventEnd - navigation.loadEventStart,
      firstInput: 0 // 需要使用 PerformanceObserver 来获取
    };

    // 获取内存使用情况（如果可用）
    const memoryUsage = (performance as any).memory ? {
      used: (performance as any).memory.usedJSHeapSize,
      total: (performance as any).memory.totalJSHeapSize,
      limit: (performance as any).memory.jsHeapSizeLimit
    } : undefined;

    return {
      timestamp: new Date().toISOString(),
      totalErrors: errors.length,
      errorsByType: errors.reduce((acc, error) => {
        acc[error.type] = (acc[error.type] || 0) + 1;
        return acc;
      }, {} as Record<string, number>),
      userActions: userActions.length,
      sessionDuration,
      memoryUsage: memoryUsage?.used,
      performanceMetrics
    };
  };

  // 建立基准线
  const establishBaseline = () => {
    const metrics = collectBaselineMetrics();
    setBaseline(metrics);
    localStorage.setItem('errorBaseline', JSON.stringify(metrics));
  };

  // 运行基准测试套件
  const runBenchmarkTests = async () => {
    setIsRunning(true);
    const results: any[] = [];

    for (const test of benchmarkTests) {
      setCurrentTest(test.name);

      try {
        // 清理之前的错误
        const beforeErrors = errorMonitor.getErrors().length;

        // 运行测试
        const result = await test.test();

        // 收集测试后状态
        const afterErrors = errorMonitor.getErrors().length;

        results.push({
          ...test,
          result,
          passed: result.errors <= test.expectedResults.maxErrors &&
                  result.duration <= test.expectedResults.maxDuration,
          errorsGenerated: afterErrors - beforeErrors
        });

      } catch (error) {
        results.push({
          ...test,
          result: { success: false, duration: 0, errors: 1 },
          passed: false,
          errorsGenerated: 1,
          error: error.message
        });
      }

      // 测试间隔
      await new Promise(resolve => setTimeout(resolve, 500));
    }

    setTestResults(results);
    setCurrentTest(null);
    setIsRunning(false);
  };

  // 与基准线比较
  const compareWithBaseline = () => {
    const currentMetrics = collectBaselineMetrics();
    const savedBaseline = localStorage.getItem('errorBaseline');
    const baselineData = savedBaseline ? JSON.parse(savedBaseline) : baseline;

    if (!baselineData) return;

    const comparison = {
      errorGrowth: currentMetrics.totalErrors - baselineData.totalErrors,
      actionGrowth: currentMetrics.userActions - baselineData.userActions,
      errorRateChange: currentMetrics.userActions > 0 ?
        ((currentMetrics.totalErrors / currentMetrics.userActions) -
         (baselineData.totalErrors / baselineData.userActions)) * 100 : 0,
      memoryGrowth: currentMetrics.memoryUsage && baselineData.memoryUsage ?
        currentMetrics.memoryUsage - baselineData.memoryUsage : 0,
      timestamp: new Date().toISOString()
    };

    setComparison(comparison);
  };

  useEffect(() => {
    // 尝试加载已保存的基准线
    const savedBaseline = localStorage.getItem('errorBaseline');
    if (savedBaseline) {
      setBaseline(JSON.parse(savedBaseline));
    }
  }, []);

  const getTestStatusColor = (passed: boolean) => {
    return passed ? 'text-green-600 bg-green-100' : 'text-red-600 bg-red-100';
  };

  const formatDuration = (ms: number) => {
    return ms < 1000 ? `${ms}ms` : `${(ms / 1000).toFixed(2)}s`;
  };

  return (
    <div className="max-w-6xl mx-auto p-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div className="flex items-center space-x-3">
          <Target className="w-8 h-8 text-blue-600" />
          <div>
            <h1 className="text-2xl font-bold text-gray-900">错误基准测试</h1>
            <p className="text-gray-600">建立错误监控基准线并验证系统稳定性</p>
          </div>
        </div>

        <div className="flex items-center space-x-3">
          <button
            onClick={establishBaseline}
            className="px-4 py-2 bg-blue-600 text-white rounded-lg flex items-center space-x-2 hover:bg-blue-700 transition-colors"
          >
            <Target className="w-4 h-4" />
            <span>建立基准线</span>
          </button>

          <button
            onClick={runBenchmarkTests}
            disabled={isRunning}
            className="px-4 py-2 bg-green-600 text-white rounded-lg flex items-center space-x-2 hover:bg-green-700 transition-colors disabled:opacity-50"
          >
            {isRunning ? (
              <>
                <Activity className="w-4 h-4 animate-spin" />
                <span>测试中...</span>
              </>
            ) : (
              <>
                <Play className="w-4 h-4" />
                <span>运行测试</span>
              </>
            )}
          </button>

          <button
            onClick={compareWithBaseline}
            className="px-4 py-2 bg-purple-600 text-white rounded-lg flex items-center space-x-2 hover:bg-purple-700 transition-colors"
          >
            <BarChart3 className="w-4 h-4" />
            <span>比较分析</span>
          </button>
        </div>
      </div>

      {/* Current Test Status */}
      {isRunning && currentTest && (
        <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
          <div className="flex items-center space-x-3">
            <Activity className="w-5 h-5 text-blue-600 animate-spin" />
            <span className="font-medium text-blue-900">正在运行: {currentTest}</span>
          </div>
        </div>
      )}

      {/* Baseline Metrics */}
      {baseline && (
        <div className="bg-white rounded-lg shadow border border-gray-200">
          <div className="p-4 border-b border-gray-200">
            <h3 className="text-lg font-semibold text-gray-900 flex items-center space-x-2">
              <Target className="w-5 h-5" />
              <span>基准线指标</span>
              <span className="text-sm text-gray-500">
                ({new Date(baseline.timestamp).toLocaleString('zh-CN')})
              </span>
            </h3>
          </div>
          <div className="p-4">
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
              <div className="text-center">
                <div className="text-2xl font-bold text-gray-900">{baseline.totalErrors}</div>
                <div className="text-sm text-gray-600">总错误数</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-blue-600">{baseline.userActions}</div>
                <div className="text-sm text-gray-600">用户操作数</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-orange-600">
                  {baseline.userActions > 0 ? (baseline.totalErrors / baseline.userActions * 100).toFixed(2) : 0}%
                </div>
                <div className="text-sm text-gray-600">错误率</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-purple-600">
                  {formatDuration(baseline.sessionDuration)}
                </div>
                <div className="text-sm text-gray-600">会话时长</div>
              </div>
            </div>

            {Object.keys(baseline.errorsByType).length > 0 && (
              <div className="mt-4">
                <h4 className="font-medium text-gray-700 mb-2">错误类型分布:</h4>
                <div className="flex flex-wrap gap-2">
                  {Object.entries(baseline.errorsByType).map(([type, count]) => (
                    <span key={type} className="px-2 py-1 bg-gray-100 rounded text-sm">
                      {type}: {count}
                    </span>
                  ))}
                </div>
              </div>
            )}
          </div>
        </div>
      )}

      {/* Comparison Results */}
      {comparison && (
        <div className="bg-white rounded-lg shadow border border-gray-200">
          <div className="p-4 border-b border-gray-200">
            <h3 className="text-lg font-semibold text-gray-900 flex items-center space-x-2">
              <TrendingUp className="w-5 h-5" />
              <span>基准线比较</span>
            </h3>
          </div>
          <div className="p-4">
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
              <div className="text-center">
                <div className={`text-2xl font-bold ${
                  comparison.errorGrowth > 0 ? 'text-red-600' : 'text-green-600'
                }`}>
                  {comparison.errorGrowth > 0 ? '+' : ''}{comparison.errorGrowth}
                </div>
                <div className="text-sm text-gray-600">错误增长</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-blue-600">
                  {comparison.actionGrowth > 0 ? '+' : ''}{comparison.actionGrowth}
                </div>
                <div className="text-sm text-gray-600">操作增长</div>
              </div>
              <div className="text-center">
                <div className={`text-2xl font-bold ${
                  comparison.errorRateChange > 0 ? 'text-red-600' : 'text-green-600'
                }`}>
                  {comparison.errorRateChange > 0 ? '+' : ''}{comparison.errorRateChange.toFixed(2)}%
                </div>
                <div className="text-sm text-gray-600">错误率变化</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-purple-600">
                  {comparison.memoryGrowth > 0 ? '+' : ''}{Math.round(comparison.memoryGrowth / 1024 / 1024)}MB
                </div>
                <div className="text-sm text-gray-600">内存增长</div>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Test Results */}
      {testResults.length > 0 && (
        <div className="bg-white rounded-lg shadow border border-gray-200">
          <div className="p-4 border-b border-gray-200">
            <h3 className="text-lg font-semibold text-gray-900">测试结果</h3>
          </div>
          <div className="divide-y divide-gray-200">
            {testResults.map((test, index) => (
              <div key={test.id} className="p-4">
                <div className="flex items-center justify-between mb-2">
                  <div className="flex items-center space-x-3">
                    <span className={`px-2 py-1 rounded text-sm font-medium ${getTestStatusColor(test.passed)}`}>
                      {test.passed ? '通过' : '失败'}
                    </span>
                    <span className="font-medium">{test.name}</span>
                  </div>
                  <div className="flex items-center space-x-4 text-sm text-gray-600">
                    <span>时长: {formatDuration(test.result.duration)}</span>
                    <span>错误: {test.errorsGenerated}</span>
                  </div>
                </div>
                <p className="text-sm text-gray-600 mb-2">{test.description}</p>
                {test.error && (
                  <div className="text-sm text-red-600 bg-red-50 p-2 rounded">
                    错误: {test.error}
                  </div>
                )}
                <div className="text-xs text-gray-500 mt-2">
                  预期: 最大{test.expectedResults.maxErrors}个错误, 最大{formatDuration(test.expectedResults.maxDuration)}
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Instructions */}
      <div className="bg-gray-50 rounded-lg p-4">
        <h3 className="font-medium text-gray-900 mb-2">使用说明</h3>
        <ol className="text-sm text-gray-700 space-y-1 list-decimal list-inside">
          <li>点击"建立基准线"收集当前系统状态作为参考基准</li>
          <li>点击"运行测试"执行一系列压力测试和错误处理测试</li>
          <li>点击"比较分析"对比当前状态与基准线的差异</li>
          <li>定期重复此过程以监控系统性能和错误率变化趋势</li>
        </ol>
      </div>
    </div>
  );
};

export default ErrorBaselineTester;