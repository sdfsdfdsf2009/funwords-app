import { useState, useCallback, useEffect, useRef } from 'react';
import { errorMonitor } from '../utils/errorMonitor';

interface ErrorState {
  hasError: boolean;
  error: Error | null;
  errorInfo: string;
  retryCount: number;
  isRetrying: boolean;
}

interface ComponentErrorHandlerOptions {
  componentName: string;
  maxRetries?: number;
  onError?: (error: Error, context?: any) => void;
  onRetry?: (retryCount: number) => void;
  onRecover?: () => void;
  enableUserFeedback?: boolean;
}

/**
 * 组件级错误处理Hook
 * 提供统一的错误处理、重试机制和用户反馈
 */
export function useComponentErrorHandler(options: ComponentErrorHandlerOptions) {
  const {
    componentName,
    maxRetries = 3,
    onError,
    onRetry,
    onRecover,
    enableUserFeedback = true
  } = options;

  const [errorState, setErrorState] = useState<ErrorState>({
    hasError: false,
    error: null,
    errorInfo: '',
    retryCount: 0,
    isRetrying: false
  });

  const [warnings, setWarnings] = useState<string[]>([]);
  const isMountedRef = useRef(true);

  // 清理函数
  useEffect(() => {
    return () => {
      isMountedRef.current = false;
    };
  }, []);

  // 安全的状态更新
  const safeSetErrorState = useCallback((updates: Partial<ErrorState>) => {
    if (isMountedRef.current) {
      setErrorState(prev => ({ ...prev, ...updates }));
    }
  }, []);

  const safeSetWarnings = useCallback((newWarnings: string[]) => {
    if (isMountedRef.current) {
      setWarnings(newWarnings);
    }
  }, []);

  // 错误处理函数
  const handleError = useCallback((error: Error | string, context?: any) => {
    const errorObj = error instanceof Error ? error : new Error(error);

    console.error(`[${componentName}] Component error:`, errorObj, context);

    // 记录到错误监控系统
    errorMonitor.logError({
      type: 'javascript',
      message: `${componentName}组件错误: ${errorObj.message}`,
      source: componentName,
      context: {
        stack: errorObj.stack,
        context,
        componentState: {
          hasError: errorState.hasError,
          retryCount: errorState.retryCount
        }
      }
    });

    // 调用自定义错误处理
    if (onError) {
      onError(errorObj, context);
    }

    // 更新错误状态
    safeSetErrorState({
      hasError: true,
      error: errorObj,
      errorInfo: typeof context === 'string' ? context : JSON.stringify(context, null, 2)
    });

    // 用户反馈
    if (enableUserFeedback) {
      errorMonitor.logUserAction('component-error', 'occur', {
        componentName,
        errorMessage: errorObj.message,
        context
      });
    }
  }, [componentName, errorState.hasError, errorState.retryCount, onError, safeSetErrorState, enableUserFeedback]);

  // 警告处理
  const addWarning = useCallback((warning: string, context?: any) => {
    console.warn(`[${componentName}] Component warning:`, warning, context);

    // 记录警告
    errorMonitor.logUserAction('component-warning', 'add', {
      componentName,
      warning,
      context
    });

    safeSetWarnings(prev => [...prev.slice(-4), warning]); // 保留最近5个警告
  }, [componentName, safeSetWarnings]);

  const clearWarnings = useCallback(() => {
    safeSetWarnings([]);
  }, [safeSetWarnings]);

  // 重试函数
  const retry = useCallback(async (retryFunction?: () => Promise<any>) => {
    if (errorState.retryCount >= maxRetries) {
      handleError(`已达到最大重试次数 (${maxRetries})`, {
        originalError: errorState.error?.message,
        retryCount: errorState.retryCount
      });
      return;
    }

    safeSetErrorState({ isRetrying: true });

    try {
      errorMonitor.logUserAction('component-retry', 'start', {
        componentName,
        retryCount: errorState.retryCount + 1,
        maxRetries
      });

      if (onRetry) {
        onRetry(errorState.retryCount + 1);
      }

      // 执行重试函数
      if (retryFunction) {
        await retryFunction();
      }

      // 重试成功
      safeSetErrorState({
        hasError: false,
        error: null,
        errorInfo: '',
        retryCount: 0,
        isRetrying: false
      });

      if (onRecover) {
        onRecover();
      }

      errorMonitor.logUserAction('component-retry', 'success', {
        componentName,
        retryCount: errorState.retryCount + 1
      });

    } catch (retryError) {
      const retryErrorObj = retryError instanceof Error ? retryError : new Error(String(retryError));

      safeSetErrorState(prev => ({
        ...prev,
        retryCount: prev.retryCount + 1,
        isRetrying: false,
        error: retryErrorObj,
        errorInfo: `重试失败 (${prev.retryCount + 1}/${maxRetries}): ${retryErrorObj.message}`
      }));

      errorMonitor.logUserAction('component-retry', 'error', {
        componentName,
        retryCount: errorState.retryCount + 1,
        error: retryErrorObj.message
      });
    }
  }, [componentName, errorState.error, errorState.retryCount, maxRetries, handleError, onRetry, onRecover, safeSetErrorState]);

  // 手动恢复函数
  const recover = useCallback(() => {
    safeSetErrorState({
      hasError: false,
      error: null,
      errorInfo: '',
      retryCount: 0,
      isRetrying: false
    });

    clearWarnings();

    errorMonitor.logUserAction('component-recover', 'manual', {
      componentName
    });

    if (onRecover) {
      onRecover();
    }
  }, [componentName, onRecover, safeSetErrorState, clearWarnings]);

  // 异步操作包装器
  const withAsyncErrorHandling = useCallback(async <T>(
    asyncFn: () => Promise<T>,
    operationName?: string,
    context?: any
  ): Promise<T | null> => {
    try {
      errorMonitor.logUserAction('async-operation', 'start', {
        componentName,
        operation: operationName || 'unknown',
        context
      });

      const result = await asyncFn();

      errorMonitor.logUserAction('async-operation', 'success', {
        componentName,
        operation: operationName || 'unknown',
        context
      });

      return result;
    } catch (error) {
      const errorObj = error instanceof Error ? error : new Error(String(error));

      handleError(errorObj, {
        operationName,
        context,
        asyncOperation: true
      });

      return null;
    }
  }, [componentName, handleError]);

  // 安全的useEffect包装器
  const useSafeEffect = useCallback((
    effect: () => void | (() => void),
    deps?: React.DependencyList
  ) => {
    useEffect(() => {
      try {
        return effect();
      } catch (error) {
        handleError(error instanceof Error ? error : new Error(String(error)), {
          type: 'useEffect',
          deps
        });
      }
    }, deps);
  }, [handleError]);

  // 安全的事件处理器
  const createSafeEventHandler = useCallback((
    handler: (event: any) => void | Promise<void>,
    eventName?: string
  ) => {
    return async (event: any) => {
      try {
        const result = handler(event);

        // 如果返回Promise，等待结果
        if (result instanceof Promise) {
          await result;
        }
      } catch (error) {
        handleError(error instanceof Error ? error : new Error(String(error)), {
          type: 'eventHandler',
          eventName: eventName || 'unknown',
          eventType: event.type
        });
      }
    };
  }, [handleError]);

  // 资源清理
  const cleanup = useCallback(() => {
    safeSetErrorState({
      hasError: false,
      error: null,
      errorInfo: '',
      retryCount: 0,
      isRetrying: false
    });
    clearWarnings();
  }, [safeSetErrorState, clearWarnings]);

  return {
    // 状态
    hasError: errorState.hasError,
    error: errorState.error,
    errorInfo: errorState.errorInfo,
    retryCount: errorState.retryCount,
    isRetrying: errorState.isRetrying,
    warnings,
    canRetry: errorState.retryCount < maxRetries,

    // 方法
    handleError,
    addWarning,
    clearWarnings,
    retry,
    recover,
    cleanup,

    // 工具函数
    withAsyncErrorHandling,
    useSafeEffect,
    createSafeEventHandler,

    // 状态检查
    hasWarnings: warnings.length > 0,
    isHealthy: !errorState.hasError && warnings.length === 0
  };
}

/**
 * 创建错误边界组件的辅助函数
 */
export function createErrorBoundaryComponent(
  WrappedComponent: React.ComponentType<any>,
  options: ComponentErrorHandlerOptions
) {
  return function ErrorBoundaryComponent(props: any) {
    const errorHandler = useComponentErrorHandler(options);

    if (errorHandler.hasError) {
      return (
        <ErrorFallback
          error={errorHandler.error}
          componentName={options.componentName}
          onRetry={() => errorHandler.retry()}
          onRecover={errorHandler.recover}
          canRetry={errorHandler.canRetry}
          retryCount={errorHandler.retryCount}
          warnings={errorHandler.warnings}
        />
      );
    }

    return <WrappedComponent {...props} errorHandler={errorHandler} />;
  };
}

/**
 * 错误回退UI组件
 */
function ErrorFallback({
  error,
  componentName,
  onRetry,
  onRecover,
  canRetry,
  retryCount,
  warnings
}: {
  error: Error | null;
  componentName: string;
  onRetry: () => void;
  onRecover: () => void;
  canRetry: boolean;
  retryCount: number;
  warnings: string[];
}) {
  return (
    <div className="flex items-center justify-center min-h-64 bg-gray-50 border border-gray-200 rounded-lg p-8">
      <div className="text-center max-w-md">
        <div className="w-16 h-16 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-4">
          <svg className="w-8 h-8 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
          </svg>
        </div>

        <h3 className="text-lg font-medium text-gray-900 mb-2">
          {componentName} 遇到了问题
        </h3>

        <div className="text-sm text-gray-600 mb-4">
          <p className="mb-2">{error?.message || '发生了一个未知错误'}</p>
          {retryCount > 0 && (
            <p className="text-xs text-gray-500">
              已重试 {retryCount} 次
            </p>
          )}
        </div>

        {/* 警告信息 */}
        {warnings.length > 0 && (
          <div className="mb-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
            <div className="text-sm text-yellow-800">
              <div className="font-medium mb-1">警告:</div>
              <ul className="list-disc list-inside space-y-1">
                {warnings.map((warning, index) => (
                  <li key={index} className="text-xs">{warning}</li>
                ))}
              </ul>
            </div>
          </div>
        )}

        {/* 操作按钮 */}
        <div className="space-y-2">
          {canRetry && (
            <button
              onClick={onRetry}
              className="w-full px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
            >
              重试 {retryCount > 0 && `(${retryCount})`}
            </button>
          )}
          <button
            onClick={onRecover}
            className="w-full px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors"
          >
            忽略错误继续
          </button>
          <button
            onClick={() => window.location.reload()}
            className="w-full px-4 py-2 text-gray-500 underline text-sm hover:text-gray-700 transition-colors"
          >
            刷新页面
          </button>
        </div>
      </div>
    </div>
  );
}

export default useComponentErrorHandler;